#### 新架构引起的变化

1. 基址+偏移的计算不再由 ALU 负责, 由独立的加法器处理. 因此删去了 ALU 前的 MUX (同时删去了其控制信号), 增加了一组加法器. 另外在译码 store 指令时, ALU_OP 无需是加法.
2. 引入了总线和内存映射 IO. 总线上挂接了 CPU, RAM 和 IO 设备. CPU 称为主设备, 其他称为从设备. 地址总线由上面提到的加法器的输出直接控制. 原先译码器输出的 RAM_WE 信号提升为总线上的写使能信号 WE. 数据总线比较复杂, 各设备通过三态门接入, 规定当 WE = 0 时, 表示 CPU (可能)发起读请求, 此时地址总线上的地址落在哪个从设备的范围内, 就由哪个从设备控制数据总线, 其他设备保持高阻态. 而当 WE = 1 时, 表示 CPU 发起写请求, 数据总线由 CPU 控制, 所有从设备保持高阻态, 并且在时钟 CLK 的上升沿, 被地址总线选中的设备将数据写入给定地址处.

#### 各部分的电路实现方法

| 部件         | 实现方法                  |
| ------------ | ------------------------- |
| PC和外围电路 | 简单IC搭                  |
| ROM          | 两片AT28C16               |
| 译码器       | 简单IC搭                  |
| 寄存器文件   | FPGA                      |
| ALU          | AT28C040, 直接烧写ALU逻辑 |
| RAM          | AT28C16加外围电路         |
| IO设备       | 做一组GPIO, 用简单IC搭    |
| 其他零碎部件 | 简单IC搭                  |

RAM 用 AT28C16 实现的方法: 添加一个比较器, 当地址不在规定的内存范围内时, 将 $\overline{CE}$ 置1, 芯片失能, I/O = Z. 总线上的 WE 直接接 $\overline{OE}$, 当地址在范围内时, 如果 WE = 0 (可能需要将 AT28C16 的 $\overline{WE}$ 强制置1. 实际测试结果: 应该不需要), 正常读取, I/O 输出到数据总线上. 如果 WE = 1, 写入操作需要 $\overline{WE}$ 上的一个负脉冲驱动. 可以考虑将系统时钟 CLK 接 $\overline{WE}$​ ,并且将 CLK 调整为具有极高占空比 (根据AT28C16要求, 低电平时间0.1~1us. 实际测试时, 延长到1ms也能正常写入), 用 CLK 驱动写入.

#### 部分命名的更改:

jal: 链接跳转

jr: 间接跳转

数据传送指令

#### 其他

可以考虑更改条件跳转的条件

以1条件跳转为例, 由原先的

```c
if(R[0]==1) PC = Imm
```

改成

```c
if(R) PC = Imm
```

也就是说, 检验全部8位, 只要有一位不为0就触发跳转, 更符合C语言中的逻辑

另外发现了一个架构的小缺陷: jal 只能取立即数作为地址, 所以对函数指针没有较好的支持, 不过可以通过较复杂的操作来弥补.

```assembly
jal $ra 下一条指令
add $ra $ra 2
jr 函数指针
```

